/*
[문제] 연속 부분수열1 - Two Pointers Algorithm

N개의 수로 이루어진 수열이 주어집니다.
이 수열에서 연속부분수열의 합이 특정숫자 M이 되는 경우가 몇 번 있는지 구하는 프로그램을
작성하세요.

만약 N=8, M=6이고 수열이 다음과 같다면
1 2 1 3 1 1 1 2
합이 6이 되는 연속부분수열은 {2, 1, 3}, {1, 3, 1, 1}, {3, 1, 1, 1}로 총 3가지입니다

[입력]
첫째 줄에 N(1≤N≤100,000), M(1≤M≤100,000,000)이 주어진다.
수열의 원소값은 1,000을 넘지 않는 자연수이다.

[출력]
첫째 줄에 경우의 수를 출력한다.

*/

const M = 6;
const arr = [1, 2, 1, 3, 1, 1, 1, 2, 4];

// 시도 1. 아래 풀이와 같은 풀이를 코드리뷰 댓글에서 확인했는데
// 가급적 영상에서 알려준 방법대로 하기를 권장한다고 답변하심...
function solution1(M, arr) {
  const N = arr.length;

  // 두 개의 포인터 lt와 rt 를 0으로 초기화
  let lt = 0;
  let rt = 0;

  // 배열의 요소를 더해 M이 되는지 확인할 sum 변수와 카운트
  let sum = 0;
  let count = 0;

  // rt 가 N 범위를 초과할 때까지 반복한다.
  // rt가 현재 요소를 먼저 더한 다음에 앞으로 이동하기 때문에, 반복을 1회 더 추가해야함.
  while (rt <= N) {
    // 만약 현재 sum이 M보다 작다면 rt를 더하고 증가한다.
    if (sum < M) {
      sum += arr[rt++];
    }
    // 만약 현재 sum이 M보다 크다면 lt를 sum에서 빼고 lt를 증가시킨다.
    else if (sum > M) {
      sum -= arr[lt++];
    }
    // 그리고 sum과 M이 동일해진다면, 카운트를 누적하고, sum에서 lt를 뺀 뒤 증가한다.
    else if (sum === M) {
      count++;
      sum -= arr[lt++];
    }
  }

  return count;
}

const result1 = solution1(M, arr);
// console.log(result1);

////////////////////////////////////
// 답안 코드
function solution2(M, arr) {
  let count = 0;
  let sum = 0;
  let lt = 0;
  const N = arr.length;

  // for문을 가지고 rt를 N 직전까지 증가시킨다.
  for (let rt = 0; rt < N; rt++) {
    // 먼저 rt 값을 더한 다음에, sum과 M이 동일하면 카운트를 증가한다.
    sum += arr[rt];
    if (sum === M) count++;
    // 계속 더하다가 sum이 M보다 크거나 같은 시점이 되면, sum에서 lt를 빼고 증가시킨 뒤에
    // 빼고 같은지 확인하고, 빼고 같은지 확인하다가 같은 순간이 되면 카운트를 증가시킨다.
    // 빼다가 M보다 작아지면 탈출한다.
    while (sum >= M) {
      sum -= arr[lt++];
      if (sum === M) count++;
    }
  }
  return count;
}

const result2 = solution2(M, arr);
console.log(result2);

/*
[풀이과정]

시도1. 
- 포인터 두 개를 만들어서, 합이 M이 될 때 까지 한 포인터를 쭉 이동시킨다.
- 합이 M이 되면 0번째 인덱스에서 기다리던 포인터를 옮겨서 그 값만큼 빼고 앞으로 이동한다.
- 합이 M보다 적으면 1번 포인터를 이동시켜서 더해주고, 합이 M보다 크면 2번 포인터를 이동시켜서 빼준다.
- 안되었던 부분 : 일단 멍청하게 count를 리턴해야 하는데 sum을 리턴해놓고 크기가 다르다고 함.. 
- 그리고 처음 조건에서는 lt 와 rt 를 모두 N 전까지 반복하는 것으로 조건을 설정했는데,
어차피 여기서 공통원소라 함은 어느 한 쪽이 끝에 다다르면 더 이상의 공통 원소는 없는 것이 되므로 rt가 끝까지 갔는지를 가지고 탐색이 끝났음을 알 수 있다.

1번 코드와 2번 코드의 차이점이 뭘까?
- 1번 코드가 바깥쪽 반복 횟수가 더 많다. rt가 N을 초과할 때 까지 도는데, 
일단 돌고 나서 증가한 뒤에 다음 반복에서 sum이 같은지 확인하기 때문에 초과해야함.
그리고 경우에 따라 모든 반복에서 rt가 증가하는 것이 아니기 때문에 반복이 for문으로 도는 것 보다는 늘어남.
- 그렇지만 2번 코드에서도 while문으로 빼는 부분을 반복하기 때문에 횟수 자체로만 보면 비슷하지 않을까... 
- 그렇다면 차이는 rt의 범위가 얼만큼 도느냐인듯. 반복을 하고 난 뒤에 같은지 확인하느냐 아니면 반복을 하는 도중에 같은지 확인하느냐 차이?

*/
