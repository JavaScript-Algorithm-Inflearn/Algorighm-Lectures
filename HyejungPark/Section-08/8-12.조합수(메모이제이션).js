/*
[문제] 조합 수(메모이제이션)

nCr = (n-1Cr-1) + (n-1Cr) 이 공식을 사용하여 재귀를 이용해 조합 수를 구해주는 프로그램 작성. 

▣ 입력설명
첫째 줄에 자연수 n(3<=n<=33)과 r(0<=r<=n)이 입력됩니다.

▣ 출력설명
첫째 줄에 조합수를 출력합니다.

▣ 입력예제 1 
5 3

▣ 출력예제 1
10

▣ 입력예제 2 
33 19

▣ 출력예제 2
818809200

*/

const n = 5;
const r = 3;

// nCr = (n-1Cr-1) + (n-1Cr)
// n 컴비네이션 r => n개 중에서 r 개를 뽑는 것.
// ex) 5C3 = 4C2 + 4C3
// 4C2 = 3C1 + 3C2
// 4C3 = 3C2 + 3C1 ...

// 그러면 컴비네이션 조합의 수를 어떻게 구하는건데요..?

/*
n개 중에서 r 개를 뽑을 때, 각 요소의 입장에서 r 개가 될 수 있는 경우는 자신이 포함되는 경우와 그렇지 않은 경우로 나눌 수 있다. 
*/

// 종료조건: r이 0이거나 n과 r이 같으면 1을 리턴한다.

// n과 r이라는 두 개의 수에 대해서 각각의 결과를 배열에 저장해둔다. => 2차원 배열...

// 잘 이해가 되지 않는 부분, 2차원 배열을 메모이제이션으로 어떻게 활용하지??

// reference
function memo(n, r) {
  // 조합으로 전달되는 n,r의 결과값이 이차원 배열에 저장된다.
  let memo = Array.from(Array(35), () => Array(35).fill(0));
  // 재귀함수
  function DFS(n, r) {
    // 먼저 n과 r을 찾았을 때 memo 배열에 있다면 그 값을 리턴한다.
    if (memo[n][r] > 0) return memo[n][r];
    // 만약 r이 0이 되거나 n과 r이 같다면(3개 중에서 3개를 뽑는 경우는 1밖에 없으므로) 1을 리턴한다.
    if (r === 0 || n === r) return 1;
    // 그 외에는 계산이 필요한 경우이므로 n과 r에 값을 저장하고 해당 값을 리턴한다.
    else return (memo[n][r] = DFS(n - 1, r - 1) + DFS(n - 1, r));
  }
  answer = DFS(n, r);
  return answer;
}

const result = memo(n, r);
console.log(result);
