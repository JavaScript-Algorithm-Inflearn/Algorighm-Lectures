/*
[문제]
이번 정보올림피아드대회에서 좋은 성적을 내기 위하여 현수는 선생님이 주신 N개의 문제를 풀려고 합니다. 
각 문제는 그것을 풀었을 때 얻는 점수와 푸는데 걸리는 시간이 주어지게 됩니다. 제한시간 M안에 N개의 문제 중 최대점수를 얻을 수 있도록 해야 합니다. 
(해당문제는 해당시간이 걸리면 푸는 걸로 간주한다, 한 유형당 한개만 풀 수 있습니다.
*/

// 해당 문제는 Brute force 방식, 즉 어떤 경우가 포함 되냐 포함되지 않느냐로 최적의 값을 구하는 방식으로 문제를 풀 수도 있다.
// 단 이 경우 모든 경우의 수 즉 O(2^n) 만큼의 시간 복잡도를 가지기 때문에, 효율성을 위해서 아래와 같이 냅색 알고리즘을 활용할 수 있다.

// 냅색 알고리즘에서 문제를 전체를 풀어나갈 수 있는 작은 문제로 쪼개야한다.

// 아래 문제에서 여러개의 문제와 점수가 있을 때, 어떤 경우는 포함될 수도 있고 어떤 경우는 포함되지 않을 수 있다. 그리고 한 문제가 중복되어서 포함되는 경우는 없다.

//////////////////////////////////////////////////
// 앞서 동전교환 문제와 비슷하지만 다른 점은...
// 이 문제에서는 한 문제에 대해서 중복을 허용하지 않는다.
// 동전 교환 알고리즘과 같게 풀어버리면, 이전에 이미 더한 문제를 다시 반복해서 더하는 결과가 나오기 때문에 그러면 안됌!
// -> 이 문제를 해결하려면 memo 배열을 뒤에서 돌면서 값을 추가하고 큰 값으로 교체해 주면 된다.

// 최소 값이 들어오는 것이 아니라, 최대 값을 구해야한다.

const limit = 20;
const questions = [
  [10, 5],
  [25, 12],
  [15, 8],
  [6, 3],
  [7, 4],
];

// 아래에서 사용되는 다이나믹 프로그래밍은 반복문을 사용한 bottom-up 방식입니다! (아마도...?)
// 단순하게 이전 결과값을 저장해두고 사용할 수도, 사용하지 않을 수도 있는 메모이제이션과는 다르더라고요.
// 메모이제이션은 DP를 구현하는 방법중에 하나이고요.
// 재귀적인 방식 + 메모이제이션을 활용하는 방법은 큰 문제 해결을 위해서 작은 문제를 호출하는 탑 다운 방식이고요.(EX 메모이제이션)
// 작은 문제부터 차근차근 풀어서 답을 도출하는 것이 보텁 업 방식입니다.
// 아래와 같이 재귀가 아닌 반복문을 활용한 방식이...

function solution(arr, l) {
  // 계산된 결과값을 저장할 dy 배열을 0으로 초기화한다.
  // 이 배열의 인덱스는 1부터 20까지, 즉 제한 시간을 나타내고 각 제한 시간만큼 최대 몇 점의 문제를 풀 수 있는지를 값으로 담고 있다.
  let dy = new Array(l + 1).fill(0);
  // 0부터 문제와 점수를 담고있는 배열을 하나씩 돈다.
  for (let i = 0; i < arr.length; i++) {
    // 한 문제를 풀었을 때 나오는 점수와 걸리는 시간을 분리한다.
    const [score, time] = arr[i];
    // 중복을 피하기 위해 가장 뒤에서 부터 time 에 해당하는 인덱스까지만 반복을 돈다.
    for (let j = l; j >= time; j--) {
      // dp가 이전에 계산했던 결과값을 무조건 활용하는 방식이므로 dy[j-time]+score 와 현재 dy[j]를 비교하는 식은 무조건 필요하다.

      // dy[j-time]이 의미하는건 무엇이냐?! 현재 시간 J 로 부터 현재 문제에 걸리는 시간 time 을 빼고 나면, 그 남는 시간에 최대 몇개의 문제를 풀 수 있는지 저장된 값이 있을 것이다!
      // 예를 들어 현재 j가 20분이고, 현재 문제를 푸는데 걸리는 시간이 8분이라면, 20분에서 8분간 문제를 풀고 남은 12분동안 풀 수 있는 문제가 저장된 dy[12]라는 값이 있다는 것! 그 값과 현재 time만큼 시간이 걸리는 문제의 score 를 더해서 최대값을 쭉~ 갱신해주면 된다는 것이다.
      dy[j] = Math.max(dy[j], dy[j - time] + score);
    }
    console.log(dy);
  }
  return dy[l];
}

const result = solution(questions, limit);
console.log(result);
