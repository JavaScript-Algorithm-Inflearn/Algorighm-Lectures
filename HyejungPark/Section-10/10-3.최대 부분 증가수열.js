/*
[문제]
N개의 자연수로 이루어진 수열이 주어졌을 때, 그 중에서 가장 길게 증가하는(작은 수에서 큰 수로) 원소들의 집합을 찾는 프로그램을 작성하라. 

예를 들어, 원소가 2, 7, 5, 8, 6, 4, 7, 12, 3 이면 가장 길게 증가하도록 원소들을 차례대로 뽑아내면 2, 5, 6, 7, 12를 뽑아내어 길이가 5인 최대 부분 증가수열을 만들 수 있다.

0부터 n 위치까지 진행 방향이 차례대로 일 때, 차례대로 증가할 수 있도록 원소를 뽑아서 부분 증가 수열을 만들어야함.

5다음 8이 오지 않는 이유는 6 다음 7이 있어서 더 많은 수를 넣을 수 있기 때문임...

현재 위치에 오기까지 만들어진 부분 수열의 길이가 얼만큼인지 보면 되는건가..? 
거기에 해당 원소를 포함할지 말지 여부를 결정하면 되는건가..? 
*/

/*
풀이를 들으면서 느낀점... 와 세상엔 천재가 많구나... 도대체 이런 생각을 어떻게 했지?!

1. 계산된 결과값을 저장하는 배열 memo의 현재 항은, 자기 자신을 마지막 숫자로 하는 부분 수열의 길이를 저장한다.
2. 전체 수열을 i로 반복하면서, 현재 숫자 이전에 자기보다 작은 값이 있는지 탐색한다. 
3. 작은 값이 있다면 그 중에서 길이가 가장 긴 부분 수열을 찾아서 1을 더해 현재 memo 에 저장해두면 되고,
4. 작은 값이 없다면 길이가 1인 (자기 자신만을 포함하는) 부분 수열이 된다.

*/

const nums = [5, 3, 7, 8, 6, 2, 9, 4]; //3,7,8,9

function solution(nums) {
  const n = nums.length;
  let memo = new Array(n).fill(0);
  memo[0] = 1;

  for (let i = 1; i < n; i++) {
    let max = 0;
    for (let j = i - 1; j >= 1; j--) {
      if (nums[j] < nums[i] && memo[j] > max) {
        max = memo[j];
      }
    }
    // 왜 안되는지 몰라서 풀이를 확인하니 코드 작성 위치가 안쪽 반복문 내부였다 ㅜㅜ
    memo[i] = max + 1;
    max = 1;
  }
  return Math.max(...memo);
}

const result = solution(nums);
console.log(result);
